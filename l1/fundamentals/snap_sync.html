<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Snap sync internals - Ethrex</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../../favicon.svg">
        <link rel="shortcut icon" href="../../favicon.png">
        <link rel="stylesheet" href="../../css/variables.css">
        <link rel="stylesheet" href="../../css/general.css">
        <link rel="stylesheet" href="../../css/chrome.css">
        <link rel="stylesheet" href="../../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Ethrex</h1>

                    <div class="right-buttons">
                        <a href="../../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/lambdaclass/ethrex" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<style>
.mdbook-alerts {
  padding: 8px 16px;
  margin-bottom: 16px;
  border-left: 0.25em solid var(--mdbook-alerts-color);
}

.mdbook-alerts > *:first-child {
  margin-top: 0;
}

.mdbook-alerts > *:last-child {
  margin-bottom: 0;
}

.mdbook-alerts-title {
  display: flex;
  font-weight: 600;
  align-items: center;
  line-height: 1;
  color: var(--mdbook-alerts-color);
  text-transform: capitalize;
}

.mdbook-alerts-icon {
  display: inline-block;
  width: 1em;
  height: 1em;
  margin-right: 0.2em;
  background-color: currentColor;
  -webkit-mask: no-repeat center / 100%;
  mask: no-repeat center / 100%;
  -webkit-mask-image: var(--mdbook-alerts-icon);
  mask-image: var(--mdbook-alerts-icon);
}

.mdbook-alerts-note {
  --mdbook-alerts-color: rgb(9, 105, 218);
  /* https://icon-sets.iconify.design/material-symbols/info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16v-4q0-.425-.288-.712T12 11q-.425 0-.712.288T11 12v4q0 .425.288.713T12 17m0-8q.425 0 .713-.288T13 8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8q0 .425.288.713T12 9m0 13q-2.075 0-3.9-.788t-3.175-2.137q-1.35-1.35-2.137-3.175T2 12q0-2.075.788-3.9t2.137-3.175q1.35-1.35 3.175-2.137T12 2q2.075 0 3.9.788t3.175 2.137q1.35 1.35 2.138 3.175T22 12q0 2.075-.788 3.9t-2.137 3.175q-1.35 1.35-3.175 2.138T12 22m0-2q3.35 0 5.675-2.325T20 12q0-3.35-2.325-5.675T12 4Q8.65 4 6.325 6.325T4 12q0 3.35 2.325 5.675T12 20m0-8"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-tip {
  --mdbook-alerts-color: rgb(26, 127, 55);
  /* https://icon-sets.iconify.design/material-symbols/lightbulb-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 22q-.825 0-1.412-.587T10 20h4q0 .825-.587 1.413T12 22m-3-3q-.425 0-.712-.288T8 18q0-.425.288-.712T9 17h6q.425 0 .713.288T16 18q0 .425-.288.713T15 19zm-.75-3q-1.725-1.025-2.738-2.75T4.5 9.5q0-3.125 2.188-5.312T12 2q3.125 0 5.313 2.188T19.5 9.5q0 2.025-1.012 3.75T15.75 16zm.6-2h6.3q1.125-.8 1.738-1.975T17.5 9.5q0-2.3-1.6-3.9T12 4Q9.7 4 8.1 5.6T6.5 9.5q0 1.35.613 2.525T8.85 14M12 14"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-important {
  --mdbook-alerts-color: rgb(130, 80, 223);
  /* https://icon-sets.iconify.design/material-symbols/chat-info-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 7q.425 0 .713-.288T13 6q0-.425-.288-.712T12 5q-.425 0-.712.288T11 6q0 .425.288.713T12 7m0 8q.425 0 .713-.288T13 14v-4q0-.425-.288-.712T12 9q-.425 0-.712.288T11 10v4q0 .425.288.713T12 15m-6 3l-2.3 2.3q-.475.475-1.088.213T2 19.575V4q0-.825.588-1.412T4 2h16q.825 0 1.413.588T22 4v12q0 .825-.587 1.413T20 18zm-.85-2H20V4H4v13.125zM4 16V4z"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-warning {
  --mdbook-alerts-color: rgb(154, 103, 0);
  /* https://icon-sets.iconify.design/material-symbols/warning-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M2.725 21q-.275 0-.5-.137t-.35-.363q-.125-.225-.137-.488t.137-.512l9.25-16q.15-.25.388-.375T12 3q.25 0 .488.125t.387.375l9.25 16q.15.25.138.513t-.138.487q-.125.225-.35.363t-.5.137zm1.725-2h15.1L12 6zM12 18q.425 0 .713-.288T13 17q0-.425-.288-.712T12 16q-.425 0-.712.288T11 17q0 .425.288.713T12 18m0-3q.425 0 .713-.288T13 14v-3q0-.425-.288-.712T12 10q-.425 0-.712.288T11 11v3q0 .425.288.713T12 15m0-2.5"%2F%3E%3C%2Fsvg%3E');
}

.mdbook-alerts-caution {
  --mdbook-alerts-color: rgb(207, 34, 46);
  /* https://icon-sets.iconify.design/material-symbols/brightness-alert-outline-rounded/ */
  --mdbook-alerts-icon: url('data:image/svg+xml,%3Csvg xmlns="http%3A%2F%2Fwww.w3.org%2F2000%2Fsvg" width="24" height="24" viewBox="0 0 24 24"%3E%3Cpath fill="currentColor" d="M12 17q.425 0 .713-.288T13 16q0-.425-.288-.712T12 15q-.425 0-.712.288T11 16q0 .425.288.713T12 17m0-4q.425 0 .713-.288T13 12V8q0-.425-.288-.712T12 7q-.425 0-.712.288T11 8v4q0 .425.288.713T12 13m-3.35 7H6q-.825 0-1.412-.587T4 18v-2.65L2.075 13.4q-.275-.3-.425-.662T1.5 12q0-.375.15-.737t.425-.663L4 8.65V6q0-.825.588-1.412T6 4h2.65l1.95-1.925q.3-.275.663-.425T12 1.5q.375 0 .738.15t.662.425L15.35 4H18q.825 0 1.413.588T20 6v2.65l1.925 1.95q.275.3.425.663t.15.737q0 .375-.15.738t-.425.662L20 15.35V18q0 .825-.587 1.413T18 20h-2.65l-1.95 1.925q-.3.275-.662.425T12 22.5q-.375 0-.737-.15t-.663-.425zm.85-2l2.5 2.5l2.5-2.5H18v-3.5l2.5-2.5L18 9.5V6h-3.5L12 3.5L9.5 6H6v3.5L3.5 12L6 14.5V18zm2.5-6"%2F%3E%3C%2Fsvg%3E');
}

</style>
<h1 id="snap-sync"><a class="header" href="#snap-sync">Snap Sync</a></h1>
<p>API reference: https://github.com/ethereum/devp2p/blob/master/caps/snap.md</p>
<p>Terminology:</p>
<ul>
<li>Peers: Other Ethereum execution clients we are connected to, and which can respond to snap requests.</li>
<li>Pivot: The block we have chosen to snap-sync to. The pivot block changes continually as it becomes too old, because nodes don't serve old data (i.e. more than 128 blocks in the past). Read below for more details on this.</li>
</ul>
<h2 id="concept"><a class="header" href="#concept">Concept</a></h2>
<h3 id="what"><a class="header" href="#what">What</a></h3>
<p>Executing all blocks to rebuild the state is slow. It is also not possible on ethrex, because we don’t support pre-merge execution. Therefore, we need to download the current state from our peers. The largest challenge in snap sync is downloading the state (the account state trie and storage state tries). Secondary concerns are downloading headers and bytecodes.</p>
<h3 id="first-solution-fast-sync"><a class="header" href="#first-solution-fast-sync">First solution: Fast-Sync</a></h3>
<p>Fast-sync is the original method used in Ethereum to download a Patricia Merkle trie. The idea is to download the trie top-down, starting from the root, then recursively downloading child nodes until the entire trie is obtained.</p>
<p><img src="./snap_sync/FastSync-1.png" alt="Initial state of simple fast sync" />
<img src="./snap_sync/FastSync-2.png" alt="Root download of simple fast sync" />
<img src="./snap_sync/FastSync-3.png" alt="Branches download of simple fast sync" />
<img src="./snap_sync/FastSync-4.png" alt="Leaves download of simple fast sync" /></p>
<p>There are two problems with this:</p>
<ul>
<li>Peers stop responding to node requests at some point. When requesting a trie node, you specify the state root for which you want the node. If the root is 128 or more blocks old, peers will not serve the request.</li>
<li>Scanning the entire trie to find missing nodes is slow.</li>
</ul>
<p>For the first problem: once peers stop serving nodes for a given root<sup class="footnote-reference" id="fr-1-1"><a href="#footnote-1">1</a></sup>, we stop fast-syncing, update the pivot, and restart the process. The naïve approach would be to download the new root and recursively fetch all its children, checking each time whether they already exist in the DB.</p>
<p>Example of a possible state after stopping fast sync due to staleness.</p>
<p><img src="./snap_sync/FastSyncRetakingExample-1.png" alt="Fast Sync Retaking Example - 1" /></p>
<p>In the example, even if we find that node { hash: 0x317f, path: 0 } is correct, we still need to check all its children in the DB (in this case none are present).</p>
<p>To solve the second problem, we introduce an optimization, which is called the "Membatch"<sup class="footnote-reference" id="fr-2-1"><a href="#footnote-2">2</a></sup>. This allows us to maintain a new invariant:</p>
<blockquote>
<p>If a node is present in the DB, then that node and all its children must be present.</p>
</blockquote>
<p>This removes the need to explore entire subtrees: when walking down the trie, if a node is in the DB, the whole subtree can be skipped.</p>
<p>To maintain this invariant, we do the following:</p>
<ul>
<li>When we get a new node, we don't immediately store it in the database. We keep track of the amount of every node's children that are not yet in the database. As long as it's not zero, we keep it in a separate in-memory structure "Membatch" instead of on the db.</li>
<li>When a node has all of its children in the db, we commit it and recursively go up the tree to see if its parent needs to be commited, etc.</li>
<li>When the nodes are written to the database, all it's parents are deleted from the db, which preserves the subtree invariant. Because lower down nodes are always written first, we never delete a valid node.</li>
</ul>
<p>Example of a possible state after stopping fast sync due to staleness with membatch.</p>
<p><img src="./snap_sync/FastSyncMembatchExample-1.png" alt="Fast Sync Membatch Example - 1" /></p>
<h3 id="speeding-up-snap-sync"><a class="header" href="#speeding-up-snap-sync">Speeding up: Snap-Sync</a></h3>
<p>Fast-sync is slow (ethrex fast-sync of a fresh “hoodi” state takes ~45 minutes—4.5× slower than snap-sync). To accelerate it, we use a key property of fast-sync:</p>
<blockquote>
<p>Fast-sync can “heal” any partial trie that obeys the invariant, even if that trie is not consistent with any real on-chain state.</p>
</blockquote>
<p>Snap sync exploits this by:</p>
<ul>
<li>downloading only the leaves (the accounts and storage slots) from any recent state</li>
<li>assembling a trie from these leaves</li>
<li>running fast-sync (“healing”) to repair it into a consistent trie.
In our code, we call the fast-sync step "healing".</li>
</ul>
<p>Example run:</p>
<p>- We download the 4 accounts in the state trie from two different blocks</p>
<p><img src="./snap_sync/SnapSyncLeaves-1.png" alt="Snap Sync Leaves - 1" /></p>
<p>- We rebuild the trie</p>
<p><img src="./snap_sync/SnapSyncHealing-1.png" alt="Snap Sync Healing - 1" /></p>
<p>- We run the healing algorithm and get a correct tree at the end of it</p>
<p>This method alone provides up to a 4-5 times boost in performance, as computing the trie is way faster than downloading it.</p>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>Generalized Flowchart of snapsync</p>
<p><img src="./snap_sync/Flow-SnapSync.png" alt="Flow - Snap Sync" /></p>
<h3 id="flags"><a class="header" href="#flags">Flags</a></h3>
<p>When developing snap sync there are flags to take into account that are used only for testing:</p>
<ul>
<li>
<p>If the <code>SKIP_START_SNAP_SYNC</code> environment variable is set and isn't empty, it will skip the step of downloading the leaves and will immediately begin healing. This simulates the behaviour of fast-sync.</p>
</li>
<li>
<p>If debug assertions are on, the program will validate that the entire state and storage tries are valid by traversing the entire trie and recomputing the roots. If any is found to be wrong, it will print an error and exit the program. This is used for debugging purposes; a validation error here means that there is 100% a bug in snap sync.</p>
</li>
<li>
<p><code>--syncmode [full, default:snap]</code> which defines what kind of sync we use. Full is executing each block, and isn't possible on a fresh sync for mainnet and sepolia.</p>
</li>
</ul>
<h3 id="file-structure"><a class="header" href="#file-structure">File Structure</a></h3>
<p>The sync module is a component of the <code>ethrex-p2p</code> crate, found in <code>crates/networking/p2p</code> folder. The main sync functions are found in:</p>
<ul>
<li><code>crates/networking/p2p/sync.rs</code></li>
<li><code>crates/networking/p2p/peer_handler.rs</code></li>
<li><code>crates/networking/p2p/sync/state_healing.rs</code></li>
<li><code>crates/networking/p2p/sync/storage_healing.rs</code></li>
<li><code>crates/networking/p2p/sync/code_collector.rs</code></li>
</ul>
<h3 id="syncer-and-sync-modes"><a class="header" href="#syncer-and-sync-modes">Syncer and Sync Modes</a></h3>
<p>The struct that handles the needed handles for syncing is the <code>Syncer</code>, and it has a variable to indicate if the snap mode is enabled. The Sync Modes are defined in <code>sync.rs</code> as follows.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>/// Manager in charge the sync process
#[derive(Debug)]
pub struct Syncer {
    /// This is also held by the SyncManager allowing it to track the latest syncmode, without modifying it
    /// No outside process should modify this value, only being modified by the sync cycle
    snap_enabled: Arc&lt;AtomicBool&gt;,
    peers: PeerHandler,
    // Used for cancelling long-living tasks upon shutdown
    cancel_token: CancellationToken,
    blockchain: Arc&lt;Blockchain&gt;,
    /// This string indicates a folder where the snap algorithm will store temporary files that are
    /// used during the syncing process
    datadir: PathBuf,
}

pub enum SyncMode {
    #[default]
    Full,
    Snap,
}
<span class="boring">}</span></code></pre></pre>
<p>The flow of the program in default mode is to start by doing snap sync, then we switch to fullsync at the end and continue catching up by executing blocks.</p>
<h3 id="downloading-headers"><a class="header" href="#downloading-headers">Downloading Headers</a></h3>
<p>The first step is downloading all the headers, through the <code>request_block_headers</code> function. This function does the following steps:</p>
<ul>
<li>Request from peers the number of the sync_head that we received from the consensus client</li>
<li>Divide the headers into discrete "chunks" to ask our peers
<ul>
<li>Currently, the headers are divided into 800 chunks<sup class="footnote-reference" id="fr-3-1"><a href="#footnote-3">3</a></sup></li>
</ul>
</li>
<li>Queue those chunks as tasks into a channel
<ul>
<li>These tasks ask the peers for their data, and respond through a channel</li>
</ul>
</li>
<li>Read from the channel to get a task</li>
<li>Finds the best free peers</li>
<li>Spawn a new async job to ask the peer for the task</li>
<li>If the channel for new is empty, check if everything is downloaded</li>
<li>Read from the channel of responses</li>
<li>Store the read result</li>
</ul>
<p><img src="./snap_sync/Flow-DownloadHeaders.png" alt="request_block_header flowchart" /></p>
<h3 id="downloading-account-values"><a class="header" href="#downloading-account-values">Downloading Account Values</a></h3>
<h4 id="api"><a class="header" href="#api">API</a></h4>
<p>When downloading the account values, we use the snap function <a href="https://github.com/ethereum/devp2p/blob/master/caps/snap.md#getaccountrange-0x00"><code>GetAccountRange</code></a>. This requests receives:</p>
<ul>
<li>rootHash: state_root of the block we're trying to download</li>
<li>startingHash: Account hash<sup class="footnote-reference" id="fr-4-1"><a href="#footnote-4">4</a></sup> of the first to retrieve</li>
<li>limitHash: Account hash after which to stop serving data</li>
<li>responseBytes: Soft limit at which to stop returning data</li>
</ul>
<p>This method returns the following</p>
<ul>
<li>accounts: List of consecutive accounts from the trie
<ul>
<li>accHash: Hash of the account address (trie path)</li>
<li>accBody: Account body in slim format</li>
</ul>
</li>
<li>proof: List of trie nodes proving the account range</li>
</ul>
<p>The proof is a merkle proof of the accounts provided, and the root of that merkle must equal to the rootHash.
In ethrex this is checked by the <code>verify_range</code> function.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>/// Verifies that the key value range belongs to the trie with the given root given the edge proofs for the range
/// Also returns true if there is more state to be fetched (aka if there are more keys to the right of the given range)
pub fn verify_range(
    root: H256,
    left_bound: &amp;H256,
    keys: &amp;[H256],
    values: &amp;[ValueRLP],
    proof: &amp;[Vec&lt;u8&gt;],
) -&gt; Result&lt;bool, TrieError&gt;
<span class="boring">}</span></code></pre></pre>
<p>We know we have finished a range if the last of the accounts downloaded is to the right of the bound we have set to the request, or if the <code>verify_range</code> returns true.</p>
<h4 id="dump-to-file"><a class="header" href="#dump-to-file">Dump to file</a></h4>
<p>To avoid having all of the accounts in memory, when their size in memory exceeds 64MiB we dump them to a new file.
These files are a subfolder of the datadir folder called <code>"account_state_snapshots"</code>.
For an optimization for faster insertion, these are stored ordered in the RocksDB sst file format.</p>
<h4 id="flowchart"><a class="header" href="#flowchart">Flowchart</a></h4>
<p><img src="./snap_sync/Flow-DownloadAccounts.png" alt="request_account_range flowchart" /></p>
<h3 id="insertion-of-accounts"><a class="header" href="#insertion-of-accounts">Insertion of Accounts</a></h3>
<p>The sst files in the <code>"account_state_snapshots"</code> subfolder are ingested into a RocksDB database. This provides an ordered array that is used for insertion.</p>
<p><a href="../../internal/l1/sorted_trie_insert.html">More detailed documentation found in sorted_trie_insert.md</a>.
<a href="../../internal/l1/sorted_trie_insert.html">More detailed documentation found in sorted_trie_insert.md</a>.</p>
<h3 id="downloading-storage-slots"><a class="header" href="#downloading-storage-slots">Downloading Storage Slots</a></h3>
<p>The download of the storage slots is conceptually similar to the download of accounts, but very different in implementation. The method uses the snap function <a href="https://github.com/ethereum/devp2p/blob/master/caps/snap.md#getstorageranges-0x02"><code>GetStorageRanges</code></a>. This requests has the following parameters:</p>
<ul>
<li>rootHash: state_root of the block we're trying to download</li>
<li>accountHashes: List of all the account address hashes of the storage tries to serve</li>
<li>startingHash: Storage slot hash of the first to retrieve</li>
<li>limitHash: Storage slot hash after which to stop serving</li>
<li>responseBytes: Soft limit at which to stop returning data</li>
</ul>
<p>The parameters <code>startingHash</code> and <code>limitHash</code> are only read when <code>accountHashes</code> is a single account.</p>
<p>The return is similar to the one from <code>GetAccountRange</code>, but with multiple results, one for each account provided, with the following parameters:</p>
<ul>
<li>slots: List of list of consecutive slots from the trie (one list per account)
<ul>
<li>slotHash: Hash of the storage slot key (trie path)</li>
<li>slotData: Data content of the slot</li>
</ul>
</li>
<li>proof: List of trie nodes proving the slot range</li>
</ul>
<p>From these parameters, there is a couple of difficulties that pop up.</p>
<ul>
<li>We need to know which accounts have storage that needs to be downloaded</li>
<li>We need to know what storage root each account has to be able to verify it</li>
</ul>
<p>To solve these issues we take two actions:</p>
<ul>
<li>Before we download the storage slots we ensure that the state trie is in a consistent complete state. This is accomplished by doing the insertion of accounts step first and then healing the trie. If during the storage slot download the pivot becomes stale, we heal the trie again with the new pivot, to keep the trie up to date.</li>
<li>When inserting the accounts, we grab a list of all the accounts with their storage root. If the account is healed, we marked the storage root as <code>None</code>, to indicate we should check in the DB what is the state of the storage root.</li>
</ul>
<h4 id="the-time-traveling-problem"><a class="header" href="#the-time-traveling-problem">The time traveling problem</a></h4>
<p>During snap sync development, we kept running into a problematic edge case: what we call "time traveling". This is when a certain account is in state A at a certain pivot, then changes to B in the next pivot, <strong>then goes back to A</strong> on a subsequent pivot change. This was a huge source of problems because it broke an invariant we assumed to be true, namely:</p>
<ul>
<li>If an account changes its state on pivot change, we will encounter it during state healing. This is NOT true if the trie is hash based.</li>
</ul>
<p>The reason for this is the time traveling scenario. When an account goes back to a state we already have on our database, we do not heal it (because we already have it), even though its state has changed. This means the code won't realize the account has changed its storage root and won't update it.</p>
<p>This should not be a problem in a path based trie (which we currently have), but it's important to keep it in mind and make sure that whatever code we write keeps this time traveling edge case in mind and solves it.</p>
<h4 id="repeated-storage-roots"><a class="header" href="#repeated-storage-roots">Repeated Storage Roots</a></h4>
<p>A large amount of the accounts with storage have exactly the same storage as other accounts.<sup class="footnote-reference" id="fr-5-1"><a href="#footnote-5">5</a></sup> As such, when we are creating tasks for download, it's important to group the tasks by storage root and not download them twice.</p>
<h4 id="big-accounts"><a class="header" href="#big-accounts">Big Accounts</a></h4>
<p>Storage trie sizes have a very uneven distribution. Around 70% of all ethereum mainnet contracts have only 1 or 2 storage slots. However, a few contracts have more storage slots than all account leaves in the entire state trie. As such, the code needs to take this pareto distribution into account to download storage tries fast.</p>
<p>At the beginning of the algorithm, we divide the accounts into chunks of 300 storage roots and their corresponding accounts. We start downloading the storage slots, until we find an account whose storage doesn't fit into a single requests. This will be indicated by the proof field having the data indicating that there are still more nodes to download in that account.</p>
<p><img src="./snap_sync/SnapSyncDownloadingStorages-1.png" alt="proofs for missing slots" /></p>
<p>When we reach that situation, we chunk the big account based on the "density"<sup class="footnote-reference" id="fr-7-1"><a href="#footnote-7">6</a></sup> of storage slots we downloaded, following this code to get chunks of 10,000 slots<sup class="footnote-reference" id="fr-6-1"><a href="#footnote-6">7</a></sup>. We create the tasks to download those intervals, and store all of the intervals in a struct to check when everything for that account was properly download.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>    // start_hash_u256 is the hash of the address of the last slot
    // slot_count is the amount of slots we have downloaded
    // The division gives us the density (maximum possible slots/actual slots downloaded) 
    // we want chunks of 10.000 slots, so we multiply those two numbers
    let storage_density = start_hash_u256 / slot_count;
    let slots_per_chunk = U256::from(10000);
    let chunk_size = storage_density
        .checked_mul(slots_per_chunk)
        .unwrap_or(U256::MAX);
<span class="boring">}</span></code></pre></pre>
<h4 id="tasks-api"><a class="header" href="#tasks-api">Tasks API</a></h4>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct StorageTask {
    // Index of the first storage account we want to download
    start_index: usize,
    // Index of the last storage account we want to download (not inclusive)
    end_index: usize,
    // startingHash, used when the task is downloading a single account
    start_hash: H256,
    // end_hash is Some if the task is to download a big task
    end_hash: Option&lt;H256&gt;,
}

struct StorageTaskResult {
    // Index of the first storage account we want to download
    start_index: usize,
    // Slots we have successfully downloaded with the hash of the slot + value
    account_storages: Vec&lt;Vec&lt;(H256, U256)&gt;&gt;,
    // Which peer answered the task, used for scoring
    peer_id: H256,
    // Index of the first storage account we still need to download
    remaining_start: usize,
    // Index of the last storage account we still need to download
    remaining_end: usize,
    // remaining_hash_range[0] is the hash of the last slot we downloaded (so we need to download starting from there)
    // remaining_hash_range[1] is the end_hash from the original StorageTask
    remaining_hash_range: (H256, Option&lt;H256&gt;),
}
<span class="boring">}</span></code></pre></pre>
<h4 id="big-accounts-flow"><a class="header" href="#big-accounts-flow">Big Accounts Flow</a></h4>
<p><img src="./snap_sync/Flow-BigAccountLogic.png" alt="Big Account logic" /></p>
<h4 id="retry-limit"><a class="header" href="#retry-limit">Retry Limit</a></h4>
<p>Currently, if ethrex has been downloading storages for more than 2 pivots, the node will stop trying to download storage, and fallback to heal (fast sync) all the storage accounts that were still missing downloads. This prevents snap sync from hanging due to an edge case we do not currently handle if an account time travels. See the "snap sync concerns" document for details on what this edge case is.</p>
<h3 id="downloading-bytecodes"><a class="header" href="#downloading-bytecodes">Downloading Bytecodes</a></h3>
<p>Whenever an account is download or healed we check if the code is not empty. If it isn't, we store it for future download. This is added to a list, and when the list grows beyond a certain size it is written to disk. After the healing is done and we have a complete state and storage tree, we start with the download of bytecodes, chunking them to avoid memory overflow.</p>
<h3 id="forkchoice-update"><a class="header" href="#forkchoice-update">Forkchoice update</a></h3>
<p>Once the entire state trie, all storage tries and contract bytecodes are downloaded, we switch the sync mode from <code>snap</code> to <code>full</code>, and we do an <code>apply_forkchoice</code> to mark that as the last pivot as the last block.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-1">
<p>We update pivots based only on the timestamp, not on the peer response. According to the spec, stale roots return empty responses, but Byzantine peers may return empty responses at arbitrary times. Therefore, we rely on the rule that nodes must keep at least 128 blocks. Once <code>time &gt; timestamp + 128 * 12</code> we mark the pivot as stale. <a href="#fr-1-1">↩</a></p>
</li>
<li id="footnote-2">
<p>The membatch is an idea taken from geth, and the name comes from their code. The name should be updated to "pendingNodes" as it reflects it current use. <a href="#fr-2-1">↩</a></p>
</li>
<li id="footnote-3">
<p>This currently isn't a named constant, we should change that <a href="#fr-3-1">↩</a></p>
</li>
<li id="footnote-4">
<p>All accounts and storages are sent and found through the hash of their address. Example: the account with address 0xf003 would be found through the 0x26c2...38c1 hash, and would be found before the account with adress 0x0001 whose hash would be 0x49d0...49d5 <a href="#fr-4-1">↩</a></p>
</li>
<li id="footnote-5">
<p>This may be for a variety of reasons, but the most likely is ERC20 tokens that were deployed and never used. <a href="#fr-5-1">↩</a></p>
</li>
<li id="footnote-7">
<p>actually <a href="https://en.wikipedia.org/wiki/Specific_volume">specific volume</a> (maximum possible slots/actual slots downloaded) <a href="#fr-7-1">↩</a></p>
</li>
<li id="footnote-6">
<p>10_000 slots is a number chosen without hard data, we should review that number. <a href="#fr-6-1">↩</a></p>
</li>
</ol>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../../l1/fundamentals/sync_modes.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../../internal/l1/delete_accounts.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../../l1/fundamentals/sync_modes.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../../internal/l1/delete_accounts.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../../elasticlunr.min.js"></script>
        <script src="../../mark.min.js"></script>
        <script src="../../searcher.js"></script>

        <script src="../../clipboard.min.js"></script>
        <script src="../../highlight.js"></script>
        <script src="../../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../../mermaid.min.js"></script>
        <script src="../../mermaid-init.js"></script>


    </div>
    </body>
</html>
